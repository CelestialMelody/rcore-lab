# RISC-V相关

> [RISC-V 手册](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)
>
> [RISC-V 指令集手册](chrome-extension://bocbaocobfecmglnmeaeppambideimao/pdf/viewer.html?file=https%3A%2F%2Fica123.com%2Fwp-content%2Fuploads%2F2021%2F03%2Friscv-privileged-spec-v1.7%25E4%25B8%25AD%25E6%2596%2587%25E7%2589%2588.pdf)

**bios和sbi是什么样的关系**

> SBI 是 RISC-V Supervisor Binary Interface 规范的缩写，OpenSBI 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用Rust语言实现的SBI。
>
> BIOS 是 Basic Input/Output System，作用是引导计算机系统的启动以及硬件测试，并向OS提供硬件抽象层。
>
> 机器上电之后，会从ROM中读取引导代码，引导整个计算机软硬件系统的启动。而整个启动过程是分为多个阶段的，现行通用的多阶段引导模型为：
>
> ROM -> LOADER -> RUNTIME -> BOOTLOADER -> OS
>
> Loader 要干的事情，就是内存初始化，以及加载 Runtime 和 BootLoader 程序。而Loader自己也是一段程序，常见的Loader就包括 BIOS 和 UEFI，后者是前者的继任者。
>
> Runtime 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，对OS提供服务，当我们要在同一套硬件系统中运行不同的操作系统，或者做硬件级别的虚拟化时，就离不开Runtime服务的支持。SBI就是RISC-V架构的Runtime规范。
>
> BootLoader 要干的事情包括文件系统引导、网卡引导、操作系统启动配置项设置、操作系统加载等等。常见的 BootLoader 包括GRUB，U-Boot，LinuxBoot等。
>
> 而 BIOS/UEFI 的大多数实现，都是 Loader、Runtime、BootLoader 三合一的，所以不能粗暴的认为 SBI 跟 BIOS/UEFI 有直接的可比性。
>
> 如果把BIOS当做一个泛化的术语使用，而不是指某个具体实现的话，那么可以认为 SBI 是 BIOS 的组成部分之一。。
>
> [解释者](https://github.com/denglj)



**ABI 与 SBI**

> [参考链接](https://blog.csdn.net/u011011827/article/details/119185091)
>
> [SBI](https://zh.m.wikipedia.org/zh-hans/%E7%89%B9%E6%9D%83%E5%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3)
>
> [ABI](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3)

- risc-v 的 sbi 是个标准 , 且 SBI 是 risc-v 独有的东西,其他架构没有这个概念；实现包括 [opensbi](https://github.com/riscv-software-src/opensbi) 和 [rustsbi](https://github.com/rustsbi/rustsbi)，这些实现都跑在M-mode，这些实现都为运行在 S-mode 上的软件(例如linux) 提供服务
- 它提供了特权层的运行环境，使得特权层软件能使用环境调用指令，来执行平台相关的操作。典型的的特权层接口应用有：
  - 类似于[Unix](https://zh.m.wikipedia.org/wiki/Unix)的操作系统中，机器级和特权级的访问接口；
  - 监视特权级和虚拟特权级中，作为虚拟化环境的调用接口。

- 常见的应用程序其实是运行在由硬件、操作系统内核、运行时库、图形界面支持库等所包起来的一个 [执行环境 (Execution Environment)](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/1what-is-os.html?highlight=abi#exec-env) 中，应用程序只需根据与系统软件约定好的应用程序二进制接口 (ABI, Application Binary Interface) 来请求执行环境提供的各种服务或功能，从而完成应用程序自己的功能
- ABI涵盖了各种细节，如：
  - 数据类型的大小、布局和对齐;
  - [调用约定](https://zh.wikipedia.org/wiki/调用约定)（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后； ([risc-v调用规范](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#term-calling-convention))
  - [系统调用](https://zh.wikipedia.org/wiki/系统调用)的编码和一个应用如何向操作系统进行系统调用；
  - 以及在一个完整的操作系统ABI中，[目标文件](https://zh.wikipedia.org/wiki/目标文件)的二进制格式、程序库等等。



**为什么 risc-v 有 sbi，其他架构没有sbi**

- 因为 risc-v 的开放性，risc-v 有 s-mode 与 m-mode 的交互, 并且开放了标准，让更多的人可以参与实现这个标准
- arm 有 EL1 与 EL2 的交互，EL2 与 EL3 的交互，但是这些交互都没有开放标准
- EL0 与 EL1 / s-mode 与 u-mode 交互没有标准, linux 有一套标准(系统调用) , win有一套标准(系统调用)



---

> [RISC-V 手册](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)
>
> [RISC-V 指令集手册](chrome-extension://bocbaocobfecmglnmeaeppambideimao/pdf/viewer.html?file=https%3A%2F%2Fica123.com%2Fwp-content%2Fuploads%2F2021%2F03%2Friscv-privileged-spec-v1.7%25E4%25B8%25AD%25E6%2596%2587%25E7%2589%2588.pdf)

**bios和sbi是什么样的关系**

> SBI 是 RISC-V Supervisor Binary Interface 规范的缩写，OpenSBI 是RISC-V官方用C语言开发的SBI参考实现；RustSBI 是用Rust语言实现的SBI。
>
> BIOS 是 Basic Input/Output System，作用是引导计算机系统的启动以及硬件测试，并向OS提供硬件抽象层。
>
> 机器上电之后，会从ROM中读取引导代码，引导整个计算机软硬件系统的启动。而整个启动过程是分为多个阶段的，现行通用的多阶段引导模型为：
>
> ROM -> LOADER -> RUNTIME -> BOOTLOADER -> OS
>
> Loader 要干的事情，就是内存初始化，以及加载 Runtime 和 BootLoader 程序。而Loader自己也是一段程序，常见的Loader就包括 BIOS 和 UEFI，后者是前者的继任者。
>
> Runtime 固件程序是为了提供运行时服务（runtime services），它是对硬件最基础的抽象，对OS提供服务，当我们要在同一套硬件系统中运行不同的操作系统，或者做硬件级别的虚拟化时，就离不开Runtime服务的支持。SBI就是RISC-V架构的Runtime规范。
>
> BootLoader 要干的事情包括文件系统引导、网卡引导、操作系统启动配置项设置、操作系统加载等等。常见的 BootLoader 包括GRUB，U-Boot，LinuxBoot等。
>
> 而 BIOS/UEFI 的大多数实现，都是 Loader、Runtime、BootLoader 三合一的，所以不能粗暴的认为 SBI 跟 BIOS/UEFI 有直接的可比性。
>
> 如果把BIOS当做一个泛化的术语使用，而不是指某个具体实现的话，那么可以认为 SBI 是 BIOS 的组成部分之一。。
>
> [解释者](https://github.com/denglj)



**ABI 与 SBI**

> [参考链接](https://blog.csdn.net/u011011827/article/details/119185091)
>
> [SBI](https://zh.m.wikipedia.org/zh-hans/%E7%89%B9%E6%9D%83%E5%B1%82%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3)
>
> [ABI](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3)

- risc-v 的 sbi 是个标准 , 且 SBI 是 risc-v 独有的东西,其他架构没有这个概念；实现包括 [opensbi](https://github.com/riscv-software-src/opensbi) 和 [rustsbi](https://github.com/rustsbi/rustsbi)，这些实现都跑在M-mode，这些实现都为运行在 S-mode 上的软件(例如linux) 提供服务
- 它提供了特权层的运行环境，使得特权层软件能使用环境调用指令，来执行平台相关的操作。典型的的特权层接口应用有：
  - 类似于[Unix](https://zh.m.wikipedia.org/wiki/Unix)的操作系统中，机器级和特权级的访问接口；
  - 监视特权级和虚拟特权级中，作为虚拟化环境的调用接口。

- 常见的应用程序其实是运行在由硬件、操作系统内核、运行时库、图形界面支持库等所包起来的一个 [执行环境 (Execution Environment)](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/1what-is-os.html?highlight=abi#exec-env) 中，应用程序只需根据与系统软件约定好的应用程序二进制接口 (ABI, Application Binary Interface) 来请求执行环境提供的各种服务或功能，从而完成应用程序自己的功能
- ABI涵盖了各种细节，如：
  - 数据类型的大小、布局和对齐;
  - [调用约定](https://zh.wikipedia.org/wiki/调用约定)（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后； ([risc-v调用规范](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#term-calling-convention))
  - [系统调用](https://zh.wikipedia.org/wiki/系统调用)的编码和一个应用如何向操作系统进行系统调用；
  - 以及在一个完整的操作系统ABI中，[目标文件](https://zh.wikipedia.org/wiki/目标文件)的二进制格式、程序库等等。



**为什么 risc-v 有 sbi，其他架构没有sbi**

- 因为 risc-v 的开放性，risc-v 有 s-mode 与 m-mode 的交互, 并且开放了标准，让更多的人可以参与实现这个标准
- arm 有 EL1 与 EL2 的交互，EL2 与 EL3 的交互，但是这些交互都没有开放标准
- EL0 与 EL1 / s-mode 与 u-mode 交互没有标准, linux 有一套标准(系统调用) , win有一套标准(系统调用)



---

[RISC-V 函数调用跳转指令](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#:~:text=%E8%BF%99%E6%A0%B7%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9A-,RISC%2DV%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4,-%23)

这两条指令在设置 pc 寄存器完成跳转功能之前，还将当前跳转指令的下一条指令地址保存在 rd 寄存器中，即 rd<-pc+4 这条指令的含义。（这里假设所有指令的长度均为 4 字节）

在 RISC-V 架构中，通常使用 `ra` 寄存器（即 `x1` 寄存器）作为其中的 `rd` 对应的具体寄存器，因此在函数返回的时候，只需跳转回 `ra` 所保存的地址即可。

事实上在函数返回的时候我们常常使用一条 **伪指令** (Pseudo Instruction) 跳转回调用之前的位置： `ret` 。它会被汇编器翻译为 `jalr x0, 0(x1)`，含义为跳转到寄存器 `ra` 保存的物理地址，由于 `x0` 是一个恒为 `0` 的寄存器，在 `rd` 中保存这一步被省略。

总结一下，在进行函数调用的时候，我们通过 `jalr` 指令保存返回地址并实现跳转；而在函数即将返回的时候，则通过 `ret` 伪指令回到跳转之前的下一条指令继续执行。这样，RISC-V 的这两条指令就实现了函数调用流程的核心机制。

> jalr x1, (imm)rs  # ra -> x1
>
> x1 <- pc + 4
>
> pc <- rs + imm
>
> 
>
> ret: jalr x0, 0(x1)
>
> x0 <- pc + 4
>
> pc <- x1 + 0

由于我们是在 `ra` 寄存器中保存返回地址的，我们要保证它在函数执行的全程不发生变化，不然在 `ret` 之后就会跳转到错误的位置。

事实上编译器除了函数调用的相关指令之外确实基本上不使用 `ra` 寄存器。也就是说，如果在函数中没有调用其他函数，那 `ra` 的值不会变化，函数调用流程能够正常工作。

但遗憾的是，在实际编写代码的时候我们常常会遇到函数 **多层嵌套调用** 的情形。

我们很容易想象，如果函数不支持嵌套调用，那么编程将会变得多么复杂。如果我们试图在一个函数 f 中调用一个子函数，在跳转到子函数 g 的同时，ra 会**被覆盖**成这条跳转指令的下一条的地址，而 ra 之前所保存的函数 f 的返回地址将会 永久丢失 。

因此，若想正确实现嵌套函数调用的控制流，我们必须通过某种方式保证：在一个函数调用子函数的前后，`ra` 寄存器的值不能发生变化。

但实际上，这并不仅仅局限于 `ra` 一个寄存器，而是作用于所有的通用寄存器。

这是因为，编译器是独立编译每个函数的，因此一个函数并不能知道它所调用的子函数修改了哪些寄存器。

而站在一个函数的视角，在调用子函数的过程中某些寄存器的值被覆盖的确会对它接下来的执行产生影响。因此这是必要的。

我们将由于函数调用，在控制流转移前后需要保持不变的寄存器集合称之为 **函数调用上下文** (Function Call Context) 。

由于每个 CPU 只有一套寄存器，我们若想在子函数调用前后保持函数调用上下文不变，就需要物理内存的帮助。

确切的说，在调用子函数之前，我们需要在物理内存中的一个区域(**栈** Stack) **保存** (Save) 函数调用上下文中的寄存器；而在函数执行完毕后，我们会从内存中同样的区域读取并 **恢复** (Restore) 函数调用上下文中的寄存器。

实际上，这一工作是由子函数的调用者和被调用者（也就是子函数自身）合作完成。函数调用上下文中的寄存器被分为如下两类：

- **被调用者保存(Callee-Saved) 寄存器** ：由被调用的函数来保证在调用前后，这些寄存器保持不变；
- **调用者保存(Caller-Saved) 寄存器** ：由发起调用的函数来保证在调用前后，这些寄存器保持不变。

从名字中可以看出，函数调用上下文由调用者和被调用者分别保存，其具体过程分别如下：

- 调用函数：首先保存不希望在函数调用过程中发生变化的 **调用者保存寄存器** ，然后通过 jal/jalr 指令调用子函数，返回之后恢复这些寄存器。
- 被调用函数：在被调用函数的起始，先保存函数执行过程中被用到的 **被调用者保存寄存器** ，然后执行函数，最后在函数退出之前恢复这些寄存器。

我们发现无论是调用函数还是被调用函数，都会因调用行为而需要**两段**匹配的保存和恢复寄存器的汇编代码，可以分别将其称为 **开场** (Prologue) 和 **结尾** (Epilogue)，它们会由编译器帮我们自动插入，来完成相关寄存器的保存与恢复。

一个函数既有可能作为调用者调用其他函数，也有可能作为被调用者被其他函数调用。



[寄存器保存与编译器优化](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#:~:text=%E6%B3%A8%E8%A7%A3-,%E5%AF%84%E5%AD%98%E5%99%A8%E4%BF%9D%E5%AD%98%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96,-%E8%BF%99%E9%87%8C%E5%80%BC%E5%BE%97%E8%AF%B4%E6%98%8E)



[调用规范](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#term-calling-convention)

**调用规范** (Calling Convention) 约定在某个指令集架构上，某种编程语言的函数调用如何实现。

1. 函数的输入参数和返回值如何传递；
2. 函数调用上下文中调用者/被调用者保存寄存器的划分；
3. 其他的在函数调用流程中对于寄存器的使用方法。

调用规范是对于一种确定的编程语言来说的，因为一般意义上的函数调用只会在编程语言的内部进行。当一种语言想要调用用另一门编程语言编写的函数接口时，编译器就需要同时清楚两门语言的调用规范，并对寄存器的使用做出调整。



[RISC-V 架构上的 C 语言调用规范](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#:~:text=%E7%9A%84%20C%20%E8%AF%AD%E8%A8%80-,%E8%B0%83%E7%94%A8%E8%A7%84%E8%8C%83,-RISC%2DV%20%E6%9E%B6%E6%9E%84)

> [RISC-V 架构上的 C 语言调用规范](https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf)
>
> Cornell 大学的 [课件内容](http://www.cs.cornell.edu/courses/cs3410/2019sp/schedule/slides/10-calling-notes-bw.pdf) 

| 寄存器组                  | 保存者       | 功能                                                     |
| ------------------------- | ------------ | -------------------------------------------------------- |
| a0~a7（ `x10~x17` ）      | 调用者保存   | 用来传递输入参数。其中的 a0 和 a1 还用来保存返回值。     |
| t0~t6( `x5~x7,x28~x31` )  | 调用者保存   | 作为临时寄存器使用，在被调函数中可以随意使用无需保存。   |
| s0~s11( `x8~x9,x18~x27` ) | 被调用者保存 | 作为临时寄存器使用，被调函数保存后才能在被调函数中使用。 |

剩下的 5 个通用寄存器情况如下：

- zero( `x0` ) 之前提到过，它恒为零，函数调用不会对它产生影响；
- ra( `x1` ) 是调用者保存的，不过它并不会在每次调用子函数的时候都保存一次，而是在函数的开头和结尾保存/恢复即可。虽然 `ra` 看上去和其它被调用者保存寄存器保存的位置一样，但是它确实是调用者保存的。（函数调用过程中，保存PC地址）
- sp( `x2` ) 是被调用者保存的。这个是之后就会提到的栈指针 (Stack Pointer) 寄存器。
- fp( `s0` )，它既可作为s0临时寄存器，也可作为栈帧指针（Frame Pointer）寄存器，表示当前栈帧的起始位置，是一个被调用者保存寄存器。
- gp( `x3` ) 和 tp( `x4` ) 在一个程序运行期间都不会变化，因此不必放在函数调用上下文中。



`sp` 寄存器常用来保存 **栈指针** (Stack Pointer)，它指向内存中栈顶地址。

在 RISC-V 架构中，栈是从高地址向低地址增长的。在一个函数中，作为起始的开场代码负责分配一块新的栈空间，即将 `sp` 的值减小相应的字节数即可

于是物理地址区间 新旧[新sp,旧sp) 对应的物理内存的一部分便可以被这个函数用来进行函数调用上下文的保存/恢复，这块物理内存被称为这个函数的 **栈帧** (Stackframe)。

同理，函数中的结尾代码负责将开场代码分配的栈帧回收，这也仅仅需要将 `sp` 的值增加相同的字节数回到分配之前的状态。这也可以解释为什么 `sp` **是一个被调用者保存寄存器。**



[栈帧 stack frame](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter1/5support-func-call.html#:~:text=%E6%B3%A8%E8%A7%A3-,%E6%A0%88%E5%B8%A7%20stack%20frame,-%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E7%A8%8B%E5%BA%8F)

<img src="./pic/CallStack.png" alt="CallStack.png" style="zoom: 25%;" />

一般而言，当前执行函数的栈帧的两个边界分别由栈指针 (Stack Pointer)寄存器和栈帧指针（frame pointer）寄存器来限定

<img src="./pic/StackFrame.png" alt="StackFrame.png" style="zoom:25%;" />

它的开头和结尾分别在 sp(x2) 和 fp(s0) 所指向的地址。按照地址从高到低分别有以下内容，它们都是通过 `sp` 加上一个偏移量来访问的：

- `ra` 寄存器保存其返回之后的跳转地址，是一个调用者保存寄存器；
- 父亲栈帧的结束地址 `fp` ，是一个被调用者保存寄存器；
- 其他被调用者保存寄存器 `s1` ~ `s11` ；
- 函数所使用到的局部变量。

因此，栈上多个 `fp` 信息实际上保存了一条完整的函数调用链，通过适当的方式我们可以实现对函数调用关系的跟踪



---

#### RISC-V 特权级架构

RISC-V 架构中一共定义了 **4 种特权级：**

| 级别 | 编码 |                名称                 |
| :--: | :--: | :---------------------------------: |
|  0   |  00  | 用户/应用模式 (U, User/Application) |
|  1   |  01  |      监督模式 (S, Supervisor)       |
|  2   |  10  |    虚拟监督模式 (H, Hypervisor)     |
|  3   |  11  |        机器模式 (M, Machine)        |

- 在CPU硬件层面，除了M模式必须存在外，其它模式可以不存在
- RISC-V 架构中，只有 M 模式是必须实现的，剩下的特权级则可以根据跑在 CPU 上应用的实际需求进行调整：
  - 简单的嵌入式应用只需要实现 M 模式；
  - 带有一定保护能力的嵌入式系统需要实现 M/U 模式；
  - 复杂的多任务系统则需要实现 M/S/U 模式。
  - 到目前为止，(Hypervisor, H)模式的特权规范还没完全制定好

[执行环境栈](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/1rv-privilege.html#:~:text=%E5%BC%A0%E5%9B%BE%E7%89%87%E7%BB%99%E5%87%BA%E4%BA%86%E8%83%BD%E5%A4%9F%E6%94%AF%E6%8C%81%E8%BF%90%E8%A1%8C%20Unix%20%E8%BF%99%E7%B1%BB%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%A0%88%E3%80%82%E5%85%B6%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9C%A8%20S%20%E6%A8%A1%E5%BC%8F%E4%B8%8A%EF%BC%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8%20U%20%E6%A8%A1%E5%BC%8F%E4%B8%8A%E3%80%82%E8%BF%90%E8%A1%8C%E5%9C%A8%20M%20%E6%A8%A1%E5%BC%8F%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%A2%AB%E7%A7%B0%E4%B8%BA%20%E7%9B%91%E7%9D%A3%E6%A8%A1%E5%BC%8F%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%20(SEE%2C%20Supervisor%20Execution%20Environment)%EF%BC%8C%E5%A6%82%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E5%89%8D%E8%B4%9F%E8%B4%A3%E5%8A%A0%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%20Bootloader%20%E2%80%93%20RustSBI%E3%80%82%E7%AB%99%E5%9C%A8%E8%BF%90%E8%A1%8C%E5%9C%A8%20S%20%E6%A8%A1%E5%BC%8F%E4%B8%8A%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%A7%86%E8%A7%92%E6%9D%A5%E7%9C%8B%EF%BC%8C%E5%AE%83%E7%9A%84%E4%B8%8B%E9%9D%A2%E4%B9%9F%E9%9C%80%E8%A6%81%E4%B8%80%E5%B1%82%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%94%AF%E6%92%91%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%A2%AB%E5%91%BD%E5%90%8D%E4%B8%BA%20SEE%EF%BC%8C%E5%AE%83%E9%9C%80%E8%A6%81%E5%9C%A8%E7%9B%B8%E6%AF%94%20S%20%E6%A8%A1%E5%BC%8F%E6%9B%B4%E9%AB%98%E7%9A%84%E7%89%B9%E6%9D%83%E7%BA%A7%E4%B8%8B%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%20SEE%20%E5%9C%A8%20M%20%E6%A8%A1%E5%BC%8F%E4%B8%8A%E8%BF%90%E8%A1%8C%E3%80%82) 

<img src="/home/clstilmldy/note/OS/rCore/pic/PrivilegeStack.png" alt="PrivilegeStack.png" style="zoom: 25%;" />

- 白色块表示一层执行环境
- 黑色块表示相邻两层执行环境之间的接口

这张图片给出了能够支持运行 Unix 这类复杂系统的软件栈。

其中操作系统内核代码运行在 S 模式上；应用程序运行在 U 模式上。运行在 M 模式上的软件被称为 **监督模式执行环境** (SEE, Supervisor Execution Environment)，如在操作系统运行前负责加载操作系统的 Bootloader – RustSBI。

站在运行在 S 模式上的软件视角来看，它的下面也需要一层执行环境支撑，因此被命名为 SEE，它需要在相比 S 模式更高的特权级下运行，一般情况下 SEE 在 M 模式上运行。



**执行环境的功能**

- 在执行它支持的上层软件之前进行一些初始化工作。

  引导加载程序会在加电后对整个系统进行初始化，它实际上是 SEE 功能的一部分，也就是说在 RISC-V 架构上的引导加载程序一般运行在 M 模式上。

- 另一种功能是对上层软件的执行进行监控管理。监控管理可以理解为，当上层软件执行的时候出现了一些异常或特殊情况，导致需要用到执行环境中提供的功能，因此需要暂停上层软件的执行，转而运行执行环境的代码。

由于上层软件和执行环境被设计为运行在不同的特权级，这个过程也往往（而 **不一定** ）伴随着 CPU 的 **特权级切换** 。

当执行环境的代码运行结束后，我们需要回到上层软件暂停的位置继续执行。

在 RISC-V 架构中，这种与常规控制流（顺序、循环、分支、函数调用）不同的 **异常控制流** (ECF, Exception Control Flow) 被称为 **异常（Exception）** ，是 RISC-V 语境下的 Trap 种类之一。



**用户态应用直接触发从用户态到内核态的异常的原因**

- 用户态软件为获得内核态操作系统的服务功能而执行特殊指令
- 在执行某条指令期间产生了错误（如执行了用户态不允许执行的指令或者其他错误）并被 CPU 检测到。



**RISC-V 特权级规范定义的会可能导致从低特权级到高特权级的各种 异常：**

| Interrupt | Exception Code | Description                    |
| --------- | -------------- | ------------------------------ |
| 0         | 0              | Instruction address misaligned |
| 0         | 1              | Instruction access fault       |
| 0         | 2              | Illegal instruction            |
| 0         | 3              | Breakpoint                     |
| 0         | 4              | Load address misaligned        |
| 0         | 5              | Load access fault              |
| 0         | 6              | Store/AMO address misaligned   |
| 0         | 7              | Store/AMO access fault         |
| 0         | 8              | Environment call from U-mode   |
| 0         | 9              | Environment call from S-mode   |
| 0         | 11             | Environment call from M-mode   |
| 0         | 12             | Instruction page fault         |
| 0         | 13             | Load page fault                |
| 0         | 15             | Store/AMO page fault           |

其中 **断点** (Breakpoint) 和 **执行环境调用** (Environment call) 两种异常（为了与其他非有意为之的异常区分，会把这种有意为之的指令称为 *陷入* 或 *trap* 类指令，此处的陷入为操作系统中传统概念）是通过在上层软件中执行一条特定的指令触发的：执行 `ebreak` 这条指令之后就会触发断点陷入异常；而执行 `ecall` 这条指令时候则会随着 CPU 当前所处特权级而触发不同的异常。从表中可以看出，当 CPU 分别处于 M/S/U 三种特权级时执行 `ecall` 这条指令会触发三种异常（分别参考上表 Exception Code 为 11/9/8 对应的行）。



**RISC-V的特权指令**

与特权级无关的一般的指令和通用寄存器 `x0` ~ `x31` 在任何特权级都可以执行。而每个特权级都对应一些特殊指令和 **控制状态寄存器** (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态。当然特权指令不仅具有读写 CSR 的指令，还有其他功能的特权指令。

如果处于低特权级状态的处理器执行了高特权级的指令，会产生非法指令错误的异常。这样，位于高特权级的执行环境能够得知低特权级的软件出现了错误，这个错误一般是不可恢复的，此时执行环境会将低特权级的软件终止。这在某种程度上体现了特权级保护机制的作用。

在 RISC-V 中，会有两类属于高特权级 S 模式的特权指令：

- 指令本身属于高特权级的指令，如 `sret` 指令（表示从 S 模式返回到 U 模式）。
- 指令访问了 [S模式特权级下才能访问的寄存器](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-s-mod-csr) 或内存，如表示S模式系统状态的 **控制状态寄存器** `sstatus` 等。

| 指令                   | 含义                                                         |
| ---------------------- | ------------------------------------------------------------ |
| sret                   | 从 S 模式返回 U 模式：在 U 模式下执行会产生非法指令异常      |
| wfi                    | 处理器在空闲时进入低功耗状态等待中断：在 U 模式下执行会产生非法指令异常 |
| sfence.vma             | 刷新 TLB 缓存：在 U 模式下执行会产生非法指令异常             |
| 访问 S 模式 CSR 的指令 | 通过访问 [sepc/stvec/scause/sscartch/stval/sstatus/satp等CSR](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-s-mod-csr) 来改变系统状态：在 U 模式下执行会产生非法指令异常 |



**系统调用**

在子模块 `syscall` 中，应用程序通过 `ecall` 调用批处理系统提供的接口，由于应用程序运行在用户态（即 U 模式）， `ecall` 指令会触发 名为 *Environment call from U-mode* 的异常，并 Trap 进入 S 模式执行批处理系统针对这个异常特别提供的服务代码。由于这个接口处于 S 模式的批处理系统和 U 模式的应用程序之间，这个接口可以被称为 ABI 或者系统调用

在实际调用的时候，需要按照 RISC-V 调用规范（即ABI格式）在合适的寄存器中放置系统调用的参数，然后执行 `ecall` 指令触发 Trap。在 Trap 回到 U 模式的应用程序代码之后，会从 `ecall` 的下一条指令继续执行，同时能够按照调用规范在合适的寄存器中读取返回值



**RISC-V 寄存器编号和别名**

RISC-V 寄存器编号从 `0~31` ，表示为 `x0~x31` 。 其中：

- `x10~x17` : 对应 `a0~a7`
- `x1` ：对应 `ra`



在 RISC-V 调用规范中，和函数调用的 ABI 情形类似，约定寄存器 `a0~a6` 保存系统调用的参数， `a0` 保存系统调用的返回值。有些许不同的是寄存器 `a7` 用来传递 syscall ID，这是因为所有的 syscall 都是通过 `ecall` 指令触发的，除了各输入参数之外我们还额外需要一个寄存器来保存要请求哪个系统调用。



---

 - 虚拟地址大小 39 bits

 - 物理地址 56 位

 - 页内偏移 (Page Offset) 12 bits

 - 虚拟地址的高 27 位，即 [38:12] 为它的虚拟页号 VPN

 - 物理地址的高 44 位，即 [55:12] 为它的物理页号 PPN
- 页号可以用来定位一个虚拟/物理地址属于哪一个虚拟页面/物理页帧

- 地址转换是以页为单位进行的，在地址转换的前后地址的页内偏移部分不变，可以认为 MMU 只是从虚拟地址中取出 27 位虚拟页号，在页表中查到其对应的物理页号（如果存在的话），最后将得到的44位的物理页号与虚拟地址的12位页内偏移依序拼接到一起就变成了56位的物理地址

- 页表项 (PTE, Page Table Entry) ，是利用虚拟页号在页表中查到的结果，大小 64 bits

- 默认情况下 MMU 未被使能，访存的地址都将直接被视作物理地址

- 可以通过修改 S 特权级的 `satp` CSR 来启用分页模式，此后 S 和 U 特权级的访存地址会被视为虚拟地址，经过 MMU 的地址转换获得对应物理地址，再通过它来访问物理内存

<p style="text-align:center">内存控制相关的CSR寄存器</p>

<img src="./pic/satp.png" alt="satp.png" style="zoom: 67%;" />

- RV64 架构下 `satp` 的 `MODE` 字段设置为 0 时，所有访存都被视为物理地址；而设置为 8 时，SV39 分页机制被启用

- SV39 分页模式下的页表项，其中 [53:10] 这 44 位是物理页号，最低的 8 位 [7:0] 则是标志位

- 最低的 8 位 [7:0] 则是标志位的含义
  - V(Valid)：仅当位 V 为 1 时，页表项才是合法的
  - R(Read)/W(Write)/X(eXecute)：分别控制索引到这个页表项的对应虚拟页面是否允许读/写/执行
  - U(User)：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问
  - G：暂且不理会
  - A(Accessed)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
  - D(Dirty)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过

 - V39 中虚拟页号被分为三级 **页索引** (Page Index) ，因此这是一种三级页表

   非叶节点（页目录表，非末级页表）的表项标志位含义和叶节点（页表，末级页表）相比有一些不同

   - 当 `V` 为 0 的时候，代表当前指针是一个空指针，无法走向下一级节点，即该页表项对应的虚拟地址范围是无效的
   - 只有当 `V` 为1 且 `R/W/X` 均为 0 时，表示是一个合法的页目录表项，其包含的指针会指向下一级的页表
   - 注意: 当 `V` 为1 且 `R/W/X` 不全为 0 时，表示是一个合法的页表项，其包含了虚地址对应的物理页号

 - RISC-V 64 架构下 `satp` 的字段分布，含义如下：

   - `MODE` 控制 CPU 使用哪种页表实现
     - 当 `MODE` 设置为 0 的时候，代表所有访存都被视为物理地址
     - 设置为 8 的时候，SV39 分页机制被启用，所有 S/U 特权级的访存被视为一个 39 位的虚拟地址，它们需要先经过 MMU 的地址转换流程，如果顺利的话，则会变成一个 56 位的物理地址来访问物理内存；否则则会触发异常，这体现了分页机制的内存保护能力
     - `ASID` 表示地址空间标识符
     - `PPN` 存的是根页表所在的物理页号,这样，给定一个虚拟页号，CPU 就可以从三级页表的根页表开始一步步的将其映射到一个物理页号
- 在 RISC-V 架构中，关于 Trap 有一条重要的规则：在 Trap 前的特权级不会高于 Trap 后的特权级。因此如果触发 Trap 之后切换到 S 特权级（下称 Trap 到 S），说明 Trap 发生之前 CPU 只能运行在 S/U 特权级。但无论如何，只要是 Trap 到 S 特权级，操作系统就会使用 S 特权级中与 Trap 相关的 **控制状态寄存器** (CSR, Control and Status Register) 来辅助 Trap 处理。我们在编写运行在 S 特权级的批处理操作系统中的 Trap 处理相关代码的时候，就需要使用如下所示的 S 模式的 CSR 寄存器。

   | CSR 名  | 该 CSR 与 Trap 相关的功能                                    |
   | ------- | ------------------------------------------------------------ |
   | sstatus | `SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 |
    | sepc    | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
   | scause  | 描述 Trap 的原因                                             |
   | stval   | 给出 Trap 附加信息                                           |
   | stvec   | 控制 Trap 处理代码的入口地址                                 |

- 一种含有快表的 RISC-V CPU 实现来说，我们可以认为 `sfence.vma` 的作用就是清空快表。事实上它在特权级规范中被定义为一种含义更加丰富的内存屏障，具体来说： `sfence.vma` 可以使得所有发生在它后面的地址转换都能够看到所有排在它前面的写入操作。在不同的硬件配置上这条指令要做的具体事务是有差异的。这条指令还可以被精细配置来减少同步开销，详情请参考 [RISC-V 特权级规范](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)(page 111,112,158)



---

[fence.i](https://five-embeddev.com/riscv-isa-manual/latest/zifencei.html)

**特权级切换相关的控制状态寄存器**

RISC-V 架构的 Trap 机制

如果中断没有被屏蔽，那么接下来就需要软件进行处理，而具体到哪个特权级进行处理与一些中断代理 CSR 的设置有关。

**默认情况下，所有的中断都需要到 M 特权级处理**。

而通过软件设置这些中断代理 CSR 之后，就可以到低特权级处理，但是 Trap 到的特权级不能低于中断的特权级。事实上所有的中断/异常默认也都是到 M 特权级处理的。

> 而通过软件设置这些中断代理 CSR 之后，就可以到低特权级处理，''但是 Trap 到的特权级不能低于中断的特权级”。引号中的内容，是想表达“中断处理程序的特权级不能低于引起中断的程序的特权”吗？
>
> 中断并非由程序引起，而是来自 I/O 外设，在 RV 架构下中断也有着特权级，如 S 态 / M 态时钟中断特权级不同。
>
> 这里要表达的是中断处理程序特权级不低于中断自身特权级。RV 中中断和异常都属于 Trap，另一条规则是 Trap 之后特权级不能变得更低。有关中断/异常/Trap的名词解释参考[这里](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter0/3os-hw-abstract.html#id9)。

考虑如下流程：当 CPU 在用户态特权级（ RISC-V 的 U 模式）运行应用程序，执行到 Trap，切换到内核态特权级（ RISC-V的S 模式），批处理操作系统的对应代码响应 Trap，并执行系统调用服务，处理完毕后，从内核态返回到用户态应用程序继续执行后续指令。

在 RISC-V 架构中，关于 Trap 有一条重要的规则：在 Trap 前的特权级不会高于 Trap 后的特权级。因此如果触发 Trap 之后切换到 S 特权级（下称 Trap 到 S），说明 Trap 发生之前 CPU 只能运行在 S/U 特权级。

但无论如何，只要是 Trap 到 S 特权级，操作系统就会使用 S 特权级中与 Trap 相关的 **控制状态寄存器** (CSR, Control and Status Register) 来辅助 Trap 处理。我们在编写运行在 S 特权级的批处理操作系统中的 Trap 处理相关代码的时候，就需要使用如下所示的 S 模式的 CSR 寄存器。

| CSR 名  | 该 CSR 与 Trap 相关的功能                                    |
| ------- | ------------------------------------------------------------ |
| sstatus | `SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 |
| sepc    | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
| scause  | 描述 Trap 的原因                                             |
| stval   | 给出 Trap 附加信息                                           |
| stvec   | 控制 Trap 处理代码的入口地址                                 |

**S模式下最重要的 sstatus 寄存器**

注意 `sstatus` 是 S 特权级最重要的 CSR，可以从多个方面控制 S 特权级的 CPU 行为和执行状态。



**特权级切换**

当执行一条 Trap 类指令（如 `ecall` 时），CPU 发现触发了一个异常并需要进行特殊处理，这涉及到 [执行环境切换](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/3os-hw-abstract.html#term-ee-switch) 。具体而言，用户态执行环境中的应用程序通过 `ecall` 指令向内核态执行环境中的操作系统请求某项服务功能，那么处理器和操作系统会完成到内核态执行环境的切换，并在操作系统完成服务后，再次切换回用户态执行环境，然后应用程序会紧接着 `ecall` 指令的后一条指令位置处继续执行

<img src="/home/clstilmldy/note/OS/rCore/pic/EnvironmentCallFlow.png" alt="EnvironmentCallFlow.png" style="zoom: 25%;" />

应用程序被切换回来之后需要从发出系统调用请求的执行位置恢复应用程序上下文并继续执行，这需要在切换前后维持应用程序的上下文保持不变。

应用程序的上下文包括通用寄存器和栈两个主要部分。

由于 CPU 在不同特权级下共享一套通用寄存器，所以在运行操作系统的 Trap 处理过程中，操作系统也会用到这些寄存器，这会改变应用程序的上下文。因此，与函数调用需要保存函数调用上下文/活动记录一样，在执行操作系统的 Trap 处理过程（会修改通用寄存器）之前，我们需要在某个地方（某内存块或内核的栈）保存这些寄存器并在 Trap 处理结束后恢复这些寄存器。

除了通用寄存器之外还有一些可能在处理 Trap 过程中会被修改的 CSR，比如 CPU 所在的特权级。我们要保证它们的变化在我们的预期之内。比如，对于特权级转换而言，应该是 Trap 之前在 U 特权级，处理 Trap 的时候在 S 特权级，返回之后又需要回到 U 特权级。而对于栈问题则相对简单，只要两个应用程序执行过程中用来记录执行历史的栈所对应的内存区域不相交，就不会产生令我们头痛的覆盖问题或数据破坏问题，也就无需进行保存/恢复。

特权级切换的具体过程一部分由硬件直接完成，另一部分则需要由操作系统来实现。



**特权级切换的硬件控制机制**

> http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf

当 CPU 执行完一条指令（如 `ecall` ）并准备从用户特权级 陷入（ `Trap` ）到 S 特权级的时候，硬件会自动完成如下这些事情：

另外一个 64 位的 CSR **`mtimecmp` 的作用是：一旦计数器 `mtime` 的值超过了 `mtimecmp`，就会触发一次时钟中断**。这使得我们可以方便的通过设置 `mtimecmp` 的值来决定下一次时钟中断何时触发。

> **stvec 相关细节**
>
> 在 RV64 中， `stvec` 是一个 64 位的 CSR，在中断使能的情况下，保存了中断处理的入口地址。它有两个字段：
>
> - MODE 位于 [1:0]，长度为 2 bits；
> - BASE 位于 [63:2]，长度为 62 bits。

当 MODE 字段为 0 的时候， `stvec` 被设置为 Direct 模式，此时进入 S 模式的 Trap 无论原因如何，处理 Trap 的入口地址都是 `BASE<<2` ， CPU 会跳转到这个地方进行异常处理。

本书中我们只会将 `stvec` 设置为 Direct 模式。而 `stvec` 还可以被设置为 Vectored 模式，有兴趣的同学可以自行参考 RISC-V 指令集特权级规范。

而当 CPU 完成 Trap 处理准备返回的时候，需要通过一条 S 特权级的特权指令 `sret` 来完成，这一条指令具体完成以下功能：

- CPU 会将当前的特权级按照 `sstatus` 的 `SPP` 字段设置为 U 或者 S ；
- CPU 会跳转到 `sepc` 寄存器指向的那条指令，然后继续执行。

这些基本上都是硬件不得不完成的事情，还有一些剩下的收尾工作可以都交给软件，让操作系统能有更大的灵活性。



**用户栈与内核栈**

在 Trap 触发的一瞬间， CPU 就会切换到 S 特权级并跳转到 stvec 所指示的位置。但是在正式进入 S 特权级的 Trap 处理之前，必须保存原控制流的寄存器状态，这一般通过内核栈来保存。注意，我们需要用专门为操作系统准备的内核栈，而不是应用程序运行时用到的用户栈。

使用两个不同的栈主要是为了安全性：如果两个控制流（即应用程序的控制流和内核的控制流）使用同一个栈，在返回之后应用程序就能读到 Trap 控制流的历史信息，比如内核一些函数的地址，这样会带来安全隐患。于是，我们要做的是，在批处理操作系统中添加一段汇编代码，实现从用户栈切换到内核栈，并在内核栈上保存应用程序控制流的寄存器状态。

`TrapContext`

里面包含所有的通用寄存器 `x0~x31` ，还有 `sstatus` 和 `sepc` 

- 对于通用寄存器而言，两条控制流（应用程序控制流和内核控制流）运行在不同的特权级，所属的软件也可能由不同的编程语言编写，虽然在 Trap 控制流中只是会执行 Trap 处理 相关的代码，但依然可能直接或间接调用很多模块，因此很难甚至不可能找出哪些寄存器无需保存。既然如此我们就只能全部保存了。但这里也有一些例外， 如 `x0` 被硬编码为 0 ，它自然不会有变化；还有 `tp(x4)` 寄存器，除非我们手动出于一些特殊用途使用它，否则一般也不会被用到。虽然它们无需保存， 但我们仍然在 `TrapContext` 中为它们预留空间，主要是为了后续的实现方便。

- 对于 CSR 而言，我们知道进入 Trap 的时候，硬件会立即覆盖掉 `scause/stval/sstatus/sepc` 的全部或是其中一部分。

  `scause/stval` 的情况是：它总是在 Trap 处理的第一时间就被使用或者是在其他地方保存下来了，因此它没有被修改并造成不良影响的风险。

  而对于 `sstatus/sepc` 而言，它们会在 Trap 处理的全程有意义（在 Trap 控制流最后 `sret` 的时候还用到了它们），而且确实会出现 Trap 嵌套的情况使得它们的值被覆盖掉。所以我们需要将它们也一起保存下来，并在 `sret` 之前恢复原样。



**CSR 相关原子指令**

> RISC-V 中读写 CSR 的指令是一类能不会被打断地完成多个读写操作的指令。这种不会被打断地完成多个操作的指令被称为 **原子指令** (Atomic Instruction)。这里的 **原子** 的含义是“不可分割的最小个体”，也就是说指令的多个操作要么都不完成，要么全部完成，而不会处于某种中间状态。
>
> 另外，RISC-V 架构中常规的数据处理和访存类指令只能操作通用寄存器而不能操作 CSR 。因此，当想要对 CSR 进行操作时，需要先使用读取 CSR 的指令将 CSR 读到一个通用寄存器中，而后操作该通用寄存器，最后再使用写入 CSR 的指令将该通用寄存器的值写入到 CSR 中。



**sscratch CSR 的用途**

> 在特权级切换的时候，我们需要将 Trap 上下文保存在内核栈上，因此需要一个寄存器暂存内核栈地址，并以它作为基地址指针来依次保存 Trap 上下文的内容。但是所有的通用寄存器都不能够用作基地址指针，因为它们都需要被保存，如果覆盖掉它们，就会影响后续应用控制流的执行。
>
> 事实上我们缺少了一个重要的中转寄存器，而 `sscratch` CSR 正是为此而生。从上面的汇编代码中可以看出，在保存 Trap 上下文的时候，它起到了两个作用：首先是保存了内核栈的地址，其次它可作为一个中转站让 `sp` （目前指向的用户栈的地址）的值可以暂时保存在 `sscratch` 。这样仅需一条 `csrrw sp, sscratch, sp` 指令（交换对 `sp` 和 `sscratch` 两个寄存器内容）就完成了从用户栈到内核栈的切换，这是一种极其精巧的实现。



---

[fence.i](https://five-embeddev.com/riscv-isa-manual/latest/zifencei.html)

**特权级切换相关的控制状态寄存器**

RISC-V 架构的 Trap 机制

- 在触发 Trap 之前 CPU 运行在哪个特权级；
- CPU 需要切换到哪个特权级来处理该 Trap ，并在处理完成之后返回原特权级。

考虑如下流程：当 CPU 在用户态特权级（ RISC-V 的 U 模式）运行应用程序，执行到 Trap，切换到内核态特权级（ RISC-V的S 模式），批处理操作系统的对应代码响应 Trap，并执行系统调用服务，处理完毕后，从内核态返回到用户态应用程序继续执行后续指令。

在 RISC-V 架构中，关于 Trap 有一条重要的规则：在 Trap 前的特权级不会高于 Trap 后的特权级。因此如果触发 Trap 之后切换到 S 特权级（下称 Trap 到 S），说明 Trap 发生之前 CPU 只能运行在 S/U 特权级。

但无论如何，只要是 Trap 到 S 特权级，操作系统就会使用 S 特权级中与 Trap 相关的 **控制状态寄存器** (CSR, Control and Status Register) 来辅助 Trap 处理。我们在编写运行在 S 特权级的批处理操作系统中的 Trap 处理相关代码的时候，就需要使用如下所示的 S 模式的 CSR 寄存器。

| CSR 名  | 该 CSR 与 Trap 相关的功能                                    |
| ------- | ------------------------------------------------------------ |
| sstatus | `SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 |
| sepc    | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
| scause  | 描述 Trap 的原因                                             |
| stval   | 给出 Trap 附加信息                                           |
| stvec   | 控制 Trap 处理代码的入口地址                                 |

**S模式下最重要的 sstatus 寄存器**

注意 `sstatus` 是 S 特权级最重要的 CSR，可以从多个方面控制 S 特权级的 CPU 行为和执行状态。



**特权级切换**

当执行一条 Trap 类指令（如 `ecall` 时），CPU 发现触发了一个异常并需要进行特殊处理，这涉及到 [执行环境切换](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/3os-hw-abstract.html#term-ee-switch) 。具体而言，用户态执行环境中的应用程序通过 `ecall` 指令向内核态执行环境中的操作系统请求某项服务功能，那么处理器和操作系统会完成到内核态执行环境的切换，并在操作系统完成服务后，再次切换回用户态执行环境，然后应用程序会紧接着 `ecall` 指令的后一条指令位置处继续执行

<img src="./pic/EnvironmentCallFlow.png" alt="EnvironmentCallFlow.png" style="zoom: 25%;" />

应用程序被切换回来之后需要从发出系统调用请求的执行位置恢复应用程序上下文并继续执行，这需要在切换前后维持应用程序的上下文保持不变。

应用程序的上下文包括通用寄存器和栈两个主要部分。

由于 CPU 在不同特权级下共享一套通用寄存器，所以在运行操作系统的 Trap 处理过程中，操作系统也会用到这些寄存器，这会改变应用程序的上下文。因此，与函数调用需要保存函数调用上下文/活动记录一样，在执行操作系统的 Trap 处理过程（会修改通用寄存器）之前，我们需要在某个地方（某内存块或内核的栈）保存这些寄存器并在 Trap 处理结束后恢复这些寄存器。

除了通用寄存器之外还有一些可能在处理 Trap 过程中会被修改的 CSR，比如 CPU 所在的特权级。我们要保证它们的变化在我们的预期之内。比如，对于特权级转换而言，应该是 Trap 之前在 U 特权级，处理 Trap 的时候在 S 特权级，返回之后又需要回到 U 特权级。而对于栈问题则相对简单，只要两个应用程序执行过程中用来记录执行历史的栈所对应的内存区域不相交，就不会产生令我们头痛的覆盖问题或数据破坏问题，也就无需进行保存/恢复。

特权级切换的具体过程一部分由硬件直接完成，另一部分则需要由操作系统来实现。



**特权级切换的硬件控制机制**

> http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf

当 CPU 执行完一条指令（如 `ecall` ）并准备从用户特权级 陷入（ `Trap` ）到 S 特权级的时候，硬件会自动完成如下这些事情：

- `sstatus` 的 `SPP` 字段会被修改为 CPU 当前的特权级（U/S）。
- `sepc` 会被修改为 Trap 处理完成后默认会执行的下一条指令的地址。
- `scause/stval` 分别会被修改成这次 Trap 的原因以及相关的附加信息。
- CPU 会跳转到 `stvec` 所设置的 Trap 处理入口地址，并将当前特权级设置为 S ，然后从Trap 处理入口地址处开始执行。

> **stvec 相关细节**
>
> 在 RV64 中， `stvec` 是一个 64 位的 CSR，在中断使能的情况下，保存了中断处理的入口地址。它有两个字段：
>
> - MODE 位于 [1:0]，长度为 2 bits；
> - BASE 位于 [63:2]，长度为 62 bits。

当 MODE 字段为 0 的时候， `stvec` 被设置为 Direct 模式，此时进入 S 模式的 Trap 无论原因如何，处理 Trap 的入口地址都是 `BASE<<2` ， CPU 会跳转到这个地方进行异常处理。

本书中我们只会将 `stvec` 设置为 Direct 模式。而 `stvec` 还可以被设置为 Vectored 模式，有兴趣的同学可以自行参考 RISC-V 指令集特权级规范。

而当 CPU 完成 Trap 处理准备返回的时候，需要通过一条 S 特权级的特权指令 `sret` 来完成，这一条指令具体完成以下功能：

- CPU 会将当前的特权级按照 `sstatus` 的 `SPP` 字段设置为 U 或者 S ；
- CPU 会跳转到 `sepc` 寄存器指向的那条指令，然后继续执行。

这些基本上都是硬件不得不完成的事情，还有一些剩下的收尾工作可以都交给软件，让操作系统能有更大的灵活性。



**用户栈与内核栈**

在 Trap 触发的一瞬间， CPU 就会切换到 S 特权级并跳转到 stvec 所指示的位置。但是在正式进入 S 特权级的 Trap 处理之前，必须保存原控制流的寄存器状态，这一般通过内核栈来保存。注意，我们需要用专门为操作系统准备的内核栈，而不是应用程序运行时用到的用户栈。

使用两个不同的栈主要是为了安全性：如果两个控制流（即应用程序的控制流和内核的控制流）使用同一个栈，在返回之后应用程序就能读到 Trap 控制流的历史信息，比如内核一些函数的地址，这样会带来安全隐患。于是，我们要做的是，在批处理操作系统中添加一段汇编代码，实现从用户栈切换到内核栈，并在内核栈上保存应用程序控制流的寄存器状态。

`TrapContext`

里面包含所有的通用寄存器 `x0~x31` ，还有 `sstatus` 和 `sepc` 

- 对于通用寄存器而言，两条控制流（应用程序控制流和内核控制流）运行在不同的特权级，所属的软件也可能由不同的编程语言编写，虽然在 Trap 控制流中只是会执行 Trap 处理 相关的代码，但依然可能直接或间接调用很多模块，因此很难甚至不可能找出哪些寄存器无需保存。既然如此我们就只能全部保存了。但这里也有一些例外， 如 `x0` 被硬编码为 0 ，它自然不会有变化；还有 `tp(x4)` 寄存器，除非我们手动出于一些特殊用途使用它，否则一般也不会被用到。虽然它们无需保存， 但我们仍然在 `TrapContext` 中为它们预留空间，主要是为了后续的实现方便。

- 对于 CSR 而言，我们知道进入 Trap 的时候，硬件会立即覆盖掉 `scause/stval/sstatus/sepc` 的全部或是其中一部分。

  `scause/stval` 的情况是：它总是在 Trap 处理的第一时间就被使用或者是在其他地方保存下来了，因此它没有被修改并造成不良影响的风险。

  而对于 `sstatus/sepc` 而言，它们会在 Trap 处理的全程有意义（在 Trap 控制流最后 `sret` 的时候还用到了它们），而且确实会出现 Trap 嵌套的情况使得它们的值被覆盖掉。所以我们需要将它们也一起保存下来，并在 `sret` 之前恢复原样。



**CSR 相关原子指令**

> RISC-V 中读写 CSR 的指令是一类能不会被打断地完成多个读写操作的指令。这种不会被打断地完成多个操作的指令被称为 **原子指令** (Atomic Instruction)。这里的 **原子** 的含义是“不可分割的最小个体”，也就是说指令的多个操作要么都不完成，要么全部完成，而不会处于某种中间状态。
>
> 另外，RISC-V 架构中常规的数据处理和访存类指令只能操作通用寄存器而不能操作 CSR 。因此，当想要对 CSR 进行操作时，需要先使用读取 CSR 的指令将 CSR 读到一个通用寄存器中，而后操作该通用寄存器，最后再使用写入 CSR 的指令将该通用寄存器的值写入到 CSR 中。



**sscratch CSR 的用途**

> 在特权级切换的时候，我们需要将 Trap 上下文保存在内核栈上，因此需要一个寄存器暂存内核栈地址，并以它作为基地址指针来依次保存 Trap 上下文的内容。但是所有的通用寄存器都不能够用作基地址指针，因为它们都需要被保存，如果覆盖掉它们，就会影响后续应用控制流的执行。
>
> 事实上我们缺少了一个重要的中转寄存器，而 `sscratch` CSR 正是为此而生。从上面的汇编代码中可以看出，在保存 Trap 上下文的时候，它起到了两个作用：首先是保存了内核栈的地址，其次它可作为一个中转站让 `sp` （目前指向的用户栈的地址）的值可以暂时保存在 `sscratch` 。这样仅需一条 `csrrw sp, sscratch, sp` 指令（交换对 `sp` 和 `sscratch` 两个寄存器内容）就完成了从用户栈到内核栈的切换，这是一种极其精巧的实现。



---

**指令长度**

riscv 指令长度只有 2 种，压缩的 16 位，不压缩的 32 位，与地址宽度无关；risc-v 64 是指地址宽度 64 位，寄存器宽度 64 位，但指令还是 32 位。



---

为何将应用的 Trap 上下文放到应用地址空间的次高页面而不是内核地址空间中的内核栈中呢？

> 原因在于，在保存 Trap 上下文到内核栈中之前，我们必须完成两项工作：
>
> 1. 必须先切换到内核地址空间，这就需要将内核地址空间的 token 写入 satp 寄存器；
> 2. 之后还需要保存应用的内核栈栈顶的位置，这样才能以它为基址保存 Trap 上下文。
>
> 这两步需要用寄存器作为临时周转，然而我们无法在不破坏任何一个通用寄存器的情况下做到这一点。
>
> 因为事实上我们需要用到内核的两条信息：内核地址空间的 token ，以及应用的内核栈栈顶的位置，RISC-V却只提供一个 `sscratch` 寄存器可用来进行周转。
>
> 所以，我们不得不将 Trap 上下文保存在应用地址空间的一个虚拟页面中，而不是切换到内核地址空间去保存。

