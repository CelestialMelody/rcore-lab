1. 这里是地址空间部分的一段关于地址与页号转换的代码部分

https://learningos.github.io/rust-based-os-comp2022/chapter4/3sv39-implementation-1.html#id5

<img src="./pic\q1.png" alt="q1" style="zoom: 50%;" />

这里使用assert_eq!(), 如果地址没有与页面大小对齐不会直接停止执行吗?感觉不会执行到v.floor()

> 回复：
>
> 没有对齐的话就panic了，不会执行v.floor；对齐的话就执行下面的v.floor



2. 联系了一下上下文，这句话看蒙了（感觉表述怪怪的）

<img src=".\pic\q2.png" alt="q2" style="zoom:50%;" />

> 回复1：
>
> 对齐的话就可以直接利用From/Into这个trait的特性 从地址转换为页号；不对齐的话，就必须显式调用floor/ceil 从地址转换为页号
>
> (my think: 所以存在无法确定是否对齐显示而显示调用的情况吗?)
>
> 回复2:
>
> 这个地方就是有问题的。实际上 from into 就是不能容纳任何可能失败的转换，可能失败就应该用 try from。其实直接用 floor ceil 就没事了



3.

刚才去搜索了一下显示调用的情况，找到了这里`os4/src/mm/frame_allocater.rs`

<img src=".\pic\q3.png" alt="q3" style="zoom:50%;" />

不过还没看到那里，还不太清楚细节。不知到说的对不对：

这里用`from`将地址转换：如果`panic`，感觉也没有办法再主动使用下面的`floor`；如果是成功转换，那么感觉`floor`执行了两次

> 回复:
>
> 不一样  第一个from是从usize转换为虚拟地址  不涉及floor；第二个floor是从虚拟地址 转换为虚拟页号



4. 请教几个操作系统的问题，关于多级页表和反向页表

我能理解：

1. 通过多级页表，可以减少内存的消耗（建立在页表，或者说一级页表能覆盖/映射所有虚拟内存）；每个进程对应一个页表
2. 反向页表，不需要容纳所有映射，且内存中只需要一个反向页表

我不能理解：

1. 为什么页表需要映射所有虚拟内存，而反向页表不需要容纳所有的映射？
2. 我看陈渝老师以前 uCore的操作系统公开课，提到使用hash，结合缓存，硬件等实现 f(PID, 逻辑页号)->物理页号，并记录在页表中。为什么这个页表就是一个反向页表呢（即页表项数目只与物理页帧数有关）？看起来与（多级）页表记录上只多了一条PID信息

以下是我通过网络搜索的相关消息：

1. https://www.zhihu.com/question/63375062
2. https://blog.csdn.net/qq_41841130/article/details/102995118

> 回复：
>
> 我也只是看书纸上谈兵的，我的理解是：
>
> 1. 页表的主要功能是从虚页号找物理页号，所以虚页号为索引物理页号为值的方案是“正向”
> 2. 每个进程在不同的地址空间，所以这样的表每个进程都有一个
> 3. 页表就是一个希望增删改查都超快并且算法还不能太复杂的数据结构（因为要实现在硬件里），最好是个静态数组
> 4. 但虚地址太大了，每个进程弄这么一个静态数组是不现实的，所以用动态分配的字典树压缩一下，因为每级字典还是静态数组而且分配次数不多所以还是很快
> 5. 但是一般物理内存都远小于虚地址空间，所以如果反着存需要的数组就很小，这个反向的页表用物理页号索引存虚地址信息，包括哪个进程映射了，映射到哪里了和怎么映射的（pid vpn flags）
> 6. 因为只有一个物理地址空间，所以这样的表只有一个
> 7. 还是需要正向查，所以再弄一个动态分配的 HashMap<(pid,vpn),ppn>，那个真正的反表实际上变成了正向哈希表的一部分，负责解决哈希冲突以及存不参与索引的 flags，并且默认进程之间不共享页，要共享还要把反向表变成邻接表（链表的数组）
>
> 以上是教科书的逻辑，补充一些我的理解：
>
> 1. 如果硬件决定内核就运行在物理地址上，可以在陷入时直接关闭 mmu，那么不支持进程之间共享页是可能的。必须通过共享内存实现进程间通信的应用程序没那么多
> 2. 仅当满足这些条件反向页表才有好处：1. 物理地址空间远小于虚地址空间 2. 一个物理页只映射给一个进程 3. 进程数量比较多（比如十几个）



5. 为什么采用多级页表？
   - 通过地址空间章节，我大概知道采用多级页表能够大大减少页表所损耗的内存。但采用线性表导致消耗大量内存是因为 **页表需要覆盖全部虚拟地址空间**，因此说“由于虚拟页号有 $2^{27}$ 种，每个虚拟页号对应一个 8 字节的页表项，则每个页表都需要消耗掉 1GiB 内存！” （共 $2^{27}$个页表）
   - 但是，多级页表的优化思想为 **按需分配**，这里提到 “反映在该应用的页表上也就是一对对映射顺次被插入进来，自然页表所占据的内存大小也就逐渐增加” ，不采用线性表不也能做到这点吗？
   - 我能想到的多级页表方式可能便于查找与插入新的页表项

>[rCore多级页表](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html#id6)
>
>事实上，对于虚拟页号 i ，如果页表（每个应用都有一个页表，这里指其中某一个）的起始地址为 base_addr ，则这个虚拟页号对应的页表项可以在物理地址 base_addr+8i 处找到。这使得 MMU 的实现和内核的软件控制都变得非常简单。然而遗憾的是，这远远超出了我们的物理内存限制。由于虚拟页号有 $2^{27}$ 种，每个虚拟页号对应一个 8 字节的页表项，则每个页表都需要消耗掉 1GiB 内存！
>
>......
>
>那么如何进行优化呢？核心思想就在于 **按需分配** ，也就是说：有多少合法的虚拟页号，我们就维护一个多大的映射，并为此使用多大的内存用来保存映射。这是因为，**每个应用的地址空间最开始都是空的，或者说所有的虚拟页号均不合法，那么这样的页表自然不需要占用任何内存， MMU 在地址转换的时候无需关心页表的内容而是将所有的虚拟页号均判为不合法即可**。而在后面，内核已经决定好了一个应用的各逻辑段存放位置之后，它就需要负责从零开始以虚拟页面为单位来让该应用的地址空间的某些部分变得合法，**反映在该应用的页表上也就是一对对映射顺次被插入进来，自然页表所占据的内存大小也就逐渐增加**。

> 地址转换是以页为单位进行的，在地址转换的前后地址的页内偏移部分不变。可以认为 MMU 只是从虚拟地址中取出 27 位虚拟页号，在页表中查到其对应的物理页号（如果存在的话），最后将得到的44位的物理页号与虚拟地址的12位页内偏移依序拼接到一起就变成了56位的物理地址。

**既然是按需分配，那么，即使不采用多级页表，为什么不能每次需要时创建一个有效的页表项？**“从虚拟地址中取出 27 位虚拟页号，在页表中查到其对应的物理页号（如果存在的话），最后将得到的44位的物理页号与虚拟地址的12位页内偏移依序拼接到一起就变成了56位的物理地址”

> [知乎链接](https://www.zhihu.com/question/63375062/answer/1403291487)的解释如下：
>
> 我们从页表的性质来看，保存在主存中的页表承担的职责是将虚拟地址翻译成物理地址；假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。**所以页表一定要覆盖全部虚拟地址空间**，不分级的页表就需要有1M个页表项来映射，而二级页表则最少只需要1K个页表项（**此时一级页表覆盖到了全部虚拟地址空间**，二级页表在需要时创建）

但前面提到：

> “每个应用的地址空间最开始都是空的，或者说所有的虚拟页号均不合法，那么这样的页表自然不需要占用任何内存， MMU 在地址转换的时候无需关心页表的内容而是将所有的虚拟页号均判为不合法即可”



> 回复：
>
> - 核心是多级页表是字典树，作为树，可以用“孩子不存在”来跳过区间上的空洞。而单级的线性表即使能动态分配也不能跳过空洞，因为线性表作为映射表需要把序号当做索引
> - 要实现页表的功能，完全可以用散列表或“段的链表”，但是要么太复杂不好做进硬件，要么复杂度高。三级页表就是三级线性表，属于折中。最巧妙的点其实是这个 4k 页，一个中间页表可以放进一个数据页，自洽了



> - 线性表怎么做到按需分配呢？虽说是使用的时候才创建，但毕竟是线性表，没创建的位置的内存也不能给别的程序用吧？
> - 线性表需要在一开始的时候就把整个表的空间都腾出来，只不过其中的表项最开始是无效表项，表示无效也要占内存的
> -  线性表是没办法一次只分配或者回收单个元素的  线性表一次就得分配一整块的区域



6. 线性表需要覆盖全部虚拟地址空间，多级页表的根页表（rCore-tutorial写的是三级页表中的第三级页表，前9个bits）是否也需要映射所有的虚拟地址空间？

- 由于虚拟页号有 $2^{27}$ 种，每个虚拟页号对应一个 8 字节的页表项，则每个页表都需要消耗掉 1GiB 内存
- 对与多级页表，如果页表需要映射所有虚拟地址空间，那么每个页表至少需要512*8B = 4KB内存（仅使用第三级页表，即可映射所有虚拟地址空间）

但是，我没有看明白以下部分（引用至rCore-tutorial）

> [分析 SV39 多级页表的内存占用](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/3sv39-implementation-1.html#id1:~:text=%E6%B3%A8%E8%A7%A3-,%E5%88%86%E6%9E%90%20SV39%20%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8,-%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%EF%BC%8C%E5%A4%9A)
>
> 设某个应用地址空间中的实际用到的总空间大小为 S 字节，则对于这个应用的 SV39 多级页表所需的内存量，有两个更加严格的上限：
>
> - 每映射一个 4KiB 的虚拟页面，需要初始就有一个页表根节点，因为还需其它两级页表节点，故最多还需要新分配两个物理页帧来保存新的节点，因此消耗内存不超过 4KiB×(1+2*S/4KiB)=4KiB+2S；
> - 考虑已经映射了很多虚拟页面，使得根节点的 512 个孩子节点都已经被分配的情况，此时最坏的情况是每次映射都需要分配一个不同的最深层节点，加上根节点的所有孩子节点并不一定都被分配，从这个角度来讲消耗内存不超过 4KiB×(1+512+S/4KiB)=4KiB+2MiB+S



7. [内核中访问物理页帧的方法](http://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/4sv39-implementation-2.html#id7:~:text=%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8D%B3%E5%8F%AF%E3%80%82-,%E5%86%85%E6%A0%B8%E4%B8%AD%E8%AE%BF%E9%97%AE%E7%89%A9%E7%90%86%E9%A1%B5%E5%B8%A7%E7%9A%84%E6%96%B9%E6%B3%95,-%23)

   > Q: 引用指向的数据活得跟程序一样久，这些物理页帧使用后怎么释放
   >
   > 引用前面的话:"`frame_alloc` 的返回值类型并不是 `FrameAllocator` 要求的物理页号 `PhysPageNum` ，而是将其进一步包装为一个 `FrameTracker` 。这里借用了 RAII 的思想，将一个物理页帧的生命周期绑定到一个 `FrameTracker` 变量上，当一个 `FrameTracker` 被创建的时候，我们需要从 `FRAME_ALLOCATOR` 中分配一个物理页帧"
   >
   > 所以是通过绑定到FrameTracker上，根据FrameTracker情况释放吗？

   > 回复包括：

   > 思考，该函数相当于复制一份物理地址（u32）,并将u32转换为指针（字面转换，这个物理地址是“真实”的物理地址）返回

   > 引用文本
   >
   > 这里简要从内存安全的角度来分析一下 `PhysPageNum` 的 `get_*` 系列方法的实现中 `unsafe` 的使用。首先需要指出的是，当需要访问一个物理页帧的时候，我们需要从它被绑定到的 `FrameTracker` 中获得其物理页号 `PhysPageNum` 随后再调用 `get_*` 系列方法才能访问物理页帧。因此， `PhysPageNum` 介于 `FrameTracker` 和物理页帧之间，也可以看做拥有部分物理页帧的所有权。由于 `get_*` 返回的是引用，我们可以尝试检查引用引发的常见问题：第一个问题是 use-after-free 的问题，即是否存在 `get_*` 返回的引用存在期间被引用的物理页帧已被回收的情形；第二个问题则是注意到 `get_*` 返回的是可变引用，那么就需要考虑对物理页帧的访问读写冲突的问题。
   >
   > 为了解决这些问题，我们在编写代码的时候需要额外当心。对于每一段 unsafe 代码，我们都需要认真考虑它会对其他无论是 unsafe 还是 safe 的代码造成的潜在影响。比如为了避免第一个问题，**我们需要保证当完成物理页帧访问之后便立即回收掉 `get_*` 返回的引用（Q:这里怎么实现的）**，至少使它不能超出 `FrameTracker` 的生命周期；考虑第二个问题，目前每个 `FrameTracker` 仅会出现一次（在它所属的进程中），因此它只会出现在一个上下文中，也就不会产生冲突。但是当内核态打开（允许）中断时，或内核支持在单进程中存在多个线程时，情况也许又会发生变化。





> - 虚拟地址大小 39 bits
>
> - 物理地址 56 位
>
> - 页内偏移 (Page Offset) 12 bits
>
> - 虚拟地址的高 27 位，即 [38:12] 为它的虚拟页号 VPN
>
> - 物理地址的高 44 位，即 [55:12] 为它的物理页号 PPN
>
> - 页号可以用来定位一个虚拟/物理地址属于哪一个虚拟页面/物理页帧
>
> - 地址转换是以页为单位进行的，在地址转换的前后地址的页内偏移部分不变，可以认为 MMU 只是从虚拟地址中取出 27 位虚拟页号，在页表中查到其对应的物理页号（如果存在的话），最后将得到的44位的物理页号与虚拟地址的12位页内偏移依序拼接到一起就变成了56位的物理地址
>
> -  页表项 (PTE, Page Table Entry) ，是利用虚拟页号在页表中查到的结果，大小 64 bits
>
> - SV39 分页模式下的页表项，其中 [53:10] 这 44 位是物理页号，最低的 8 位 [7:0] 则是标志位
>
> - 最低的 8 位 [7:0] 则是标志位的含义
>
>   - V(Valid)：仅当位 V 为 1 时，页表项才是合法的
>   - R(Read)/W(Write)/X(eXecute)：分别控制索引到这个页表项的对应虚拟页面是否允许读/写/执行
>   - U(User)：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问
>   - G：暂且不理会
>   - A(Accessed)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
>   - D(Dirty)：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过
>
> - V39 中虚拟页号被分为三级 **页索引** (Page Index) ，因此这是一种三级页表
>
>   非叶节点（页目录表，非末级页表）的表项标志位含义和叶节点（页表，末级页表）相比有一些不同
>
>   - 当 `V` 为 0 的时候，代表当前指针是一个空指针，无法走向下一级节点，即该页表项对应的虚拟地址范围是无效的
>   - 只有当 `V` 为1 且 `R/W/X` 均为 0 时，表示是一个合法的页目录表项，其包含的指针会指向下一级的页表
>   - 注意: 当 `V` 为1 且 `R/W/X` 不全为 0 时，表示是一个合法的页表项，其包含了虚地址对应的物理页号
>
> - RISC-V 64 架构下 `satp` 的字段分布，含义如下：
>
>   - `MODE` 控制 CPU 使用哪种页表实现
>     - 当 `MODE` 设置为 0 的时候，代表所有访存都被视为物理地址
>     - 设置为 8 的时候，SV39 分页机制被启用，所有 S/U 特权级的访存被视为一个 39 位的虚拟地址，它们需要先经过 MMU 的地址转换流程，如果顺利的话，则会变成一个 56 位的物理地址来访问物理内存；否则则会触发异常，这体现了分页机制的内存保护能力
>   - `ASID` 表示地址空间标识符
>   - `PPN` 存的是根页表所在的物理页号,这样，给定一个虚拟页号，CPU 就可以从三级页表的根页表开始一步步的将其映射到一个物理页号
>
> - 在 RISC-V 架构中，关于 Trap 有一条重要的规则：在 Trap 前的特权级不会高于 Trap 后的特权级。因此如果触发 Trap 之后切换到 S 特权级（下称 Trap 到 S），说明 Trap 发生之前 CPU 只能运行在 S/U 特权级。但无论如何，只要是 Trap 到 S 特权级，操作系统就会使用 S 特权级中与 Trap 相关的 **控制状态寄存器** (CSR, Control and Status Register) 来辅助 Trap 处理。我们在编写运行在 S 特权级的批处理操作系统中的 Trap 处理相关代码的时候，就需要使用如下所示的 S 模式的 CSR 寄存器。
>
>   | CSR 名  | 该 CSR 与 Trap 相关的功能                                    |
>   | ------- | ------------------------------------------------------------ |
>   | sstatus | `SPP` 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息 |
>   | sepc    | 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址 |
>   | scause  | 描述 Trap 的原因                                             |
>   | stval   | 给出 Trap 附加信息                                           |
>   | stvec   | 控制 Trap 处理代码的入口地址                                 |



> - 内核内存布局 `os/src/linker.ld`
